<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gzmviavia</title>
  <subtitle>this is a blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-08-07T04:49:17.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>gzmviavia</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>地址解析协议ARP</title>
    <link href="http://yoursite.com/2016/08/07/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AEARP/"/>
    <id>http://yoursite.com/2016/08/07/地址解析协议ARP/</id>
    <published>2016-08-07T02:40:38.000Z</published>
    <updated>2016-08-07T04:49:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据链路层的作用"><a href="#数据链路层的作用" class="headerlink" title="数据链路层的作用"></a>数据链路层的作用</h2><p>数据链路层有三个作用</p>
<ol>
<li>为上层的IP模块发送和接收IP数据包。</li>
<li>为ARP模块发送ARP请求和接收ARP应答。</li>
<li>为RARP模块发送RARP请求和接收RARP应答。</li>
</ol>
<a id="more"></a>
<p><img src="http://obil5saf9.bkt.clouddn.com/arp1.png" alt="Alt 数据链路层首部"></p>
<p>上图是以太网的帧格式。</p>
<p>目的地址：目标主机的MAC地址。</p>
<p>源地址：源主机的MAC地址。</p>
<p>类型：该帧通过2个字节的类型字段来标识当前帧的用来干嘛的</p>
<p>当类型为0x0800时，将该帧的数据部分交给IP协议处理。</p>
<p>当类型为0x0806时，将该帧的数据部分交给ARP协议处理。</p>
<p>当类型为0x8035时，将该帧的数据部分交给RARP协议处理。</p>
<p>当交换机收到以太网帧时，判断该帧的MAC地址：</p>
<p>如果该帧的MAC地址是ff:ff:ff:ff:ff:ff，表明这是一个广播帧，那么交换机就向所有的端口（除了接收到该帧的端口之外）转发该帧。</p>
<p>如果该帧不是一个广播帧，那么就交换机就查找转发表，看该MAC地址对应了哪个端口，然后就从相应的端口转发出去。</p>
<p>如果转发表中找不到该MAC地址对应的端口该怎么办？也象处理广播帧一样转发该帧。</p>
<h2 id="ARP协议的报文格式与工作原理"><a href="#ARP协议的报文格式与工作原理" class="headerlink" title="ARP协议的报文格式与工作原理"></a>ARP协议的报文格式与工作原理</h2><p>ARP协议是属于数据链路层的协议，所以说它是一个局域网协议，也就是说它只能在局域网内部运行。</p>
<p><img src="http://obil5saf9.bkt.clouddn.com/arp2.png" alt="Alt 数据链路层首部"></p>
<p>硬件类型：硬件地址的类型，如果是以太网，则该字段为1。</p>
<p>协议类型：一般为0x0080，表示ipv4协议。</p>
<p>硬件地址长度：一般为6，硬件地址的长度为6个字节。</p>
<p>协议地址长度：一般为4，ipv4地址的长度为4个字节。</p>
<p>操作类型：1为ARP请求，2为ARP应答，3为RARP请求，4为RARP应答。</p>
<p>发送端以太网地址：发送方的MAC地址。</p>
<p>发送端IP地址：发送方的IP地址。</p>
<p>目的以太网地址：目的主机的MAC地址，当为ARP请求时，该字段全为0。</p>
<p>目的IP地址：目的主机的IP地址。</p>
<p>那么ARP协议是如何工作的呢？</p>
<p>我用wireshark抓了个ARP包，这样就能从实际上+原理上分析出ARP是如何工作的。</p>
<p><img src="http://obil5saf9.bkt.clouddn.com/arp3.png" alt="Alt 数据链路层首部"></p>
<p>本机的IP地址是197.168.1.100，MAC地址是e0:ac:cb:81:37:9e，因为e0:ac:cb表示该网卡是苹果生产的，所以简写成Apple_81:37:9e，我想知道IP地址为197.168.1.101的MAC地址，所以发送了一个ARP广播。</p>
<p><img src="http://obil5saf9.bkt.clouddn.com/arp4.png" alt="Alt 数据链路层首部"></p>
<p>上图是该帧的详细信息，我的电脑封装好该帧之后就发送给交换机了，交换机收到该帧之后，发现目的地址是广播地址，所以向所有的端口转发该帧，当然了，不会向我转发该帧的。</p>
<p>所以该局域网内的所有主机都会收到该帧，之后每个主机会使用ARP协议解析该帧，然后会根据该帧中的目标主机的IP地址判断该帧是不是发送自己的，如果不是发送给自己的，那么就丢弃该帧；如果是发送给自己的，那么就会发送一个ARP应答帧。</p>
<p>目的主机发送了一个应答帧给我，我的电脑收到该ARP应答帧之后就会提取出其中的Sender Mac address 和Sender IP address，并将两者的对应关系写入本机的ARP缓存中，当然了该缓存中的每条记录都有一个过期时间的，一般为20分钟。</p>
<p><img src="http://obil5saf9.bkt.clouddn.com/arp5.png" alt="Alt 数据链路层首部"></p>
<h2 id="什么时候会使用arp请求协议"><a href="#什么时候会使用arp请求协议" class="headerlink" title="什么时候会使用arp请求协议"></a>什么时候会使用arp请求协议</h2><p>当主机A需要知道自己同属于一个局域网的某个IP地址所对应的MAC地址时，就会去ARP缓存中查找IP地址对应的MAC地址，</p>
<p>如果不存在，那么就会发出一个ARP请求。</p>
<p>主机A要和主机B进行通信，主机A会判断主机B是不是和自己在同一个网段。</p>
<p>如果是和自己在同一个网段，那么帧首部的目的地址就会填主机B的MAC地址，那么交换机收到该帧之后就会发给主机B。</p>
<p>如果不是和自己在同一个网段，那么就属于跨子网通信，需要路由器的帮助，那么帧的首部的目的地址就要填网关的MAC地址（路由器就是网关的一种），交换机收到该帧之后就会将该帧转发给路由器，路由器收到该帧后会解封该帧，变成IP数据报，</p>
<p>然后查看目的IP地址发现该IP数据报是发往另一个网段的，就会查看路由表，从其它端口转发出去。</p>
<h2 id="ARP欺骗和中间人攻击"><a href="#ARP欺骗和中间人攻击" class="headerlink" title="ARP欺骗和中间人攻击"></a>ARP欺骗和中间人攻击</h2><p>ARP的设计是有缺陷的，即主机收到一个ARP应答帧之后，会从中取出对方主机的IP地址和MAC地址，然后将其对应关系写入到ARP缓存中。没错，主机不会关心自己到底有没有发送过该ARP请求包。</p>
<p>所以黑客可以通过发送伪造的ARP应答帧来进行攻击，ARP欺骗一下有三种方式：</p>
<h3 id="1-伪造主机："><a href="#1-伪造主机：" class="headerlink" title="1. 伪造主机："></a>1. 伪造主机：</h3><p>主机A的IP地址是192.168.1.2，MAC地址是AA:AA:AA:AA:AA:AA</p>
<p>主机B的IP地址是192.168.1.3，MAC地址是BB:BB:BB:BB:BB:BB</p>
<p>主机A源源不断得向网关发送应答帧，将该应答帧的发送端以太网地址设置成AA:AA:AA:AA:AA:AA，</p>
<p>但是却将发送端IP地址设置成192.168.1.3，那么此时网关的ARP缓存表中就有一项是</p>
<p>192.168.1.3  AA:AA:AA:AA:AA:AA</p>
<p>那么网关就会将发送给192.168.1.3的IP数据包封装成帧的时候目的MAC地址填写成AA:AA:AA:AA:AA:AA，</p>
<p>我们知道局域网是使用MAC地址寻址的，所以最终该帧会被转发给主机A。</p>
<h3 id="2-伪造网关"><a href="#2-伪造网关" class="headerlink" title="2. 伪造网关:"></a>2. 伪造网关:</h3><p>主机A的IP地址是192.168.1.2，MAC地址是AA:AA:AA:AA:AA:AA</p>
<p>网关的IP地址是192.168.1.1，MAC地址是GG:GG:GG:GG:GG:GG</p>
<p>主机A源源不断得向被攻击主机B发送应答帧，将该应答帧的发送端以太网地址设置成AA:AA:AA:AA:AA:AA，</p>
<p>但是却将发送端IP地址设置成192.168.1.1，那么此时主机B的ARP缓存表中就有一项是</p>
<p>192.168.1.1 AA:AA:AA:AA:AA:AA</p>
<p>那么所有从主机B发给网关的IP数据包被封装成帧时，都会将目的MAC地址填写成AA:AA:AA:AA:AA:AA，</p>
<p>所以该帧最终会被转发给主机A。</p>
<h3 id="3-中间人攻击（伪造主机-伪造网关）"><a href="#3-中间人攻击（伪造主机-伪造网关）" class="headerlink" title="3. 中间人攻击（伪造主机+伪造网关）"></a>3. 中间人攻击（伪造主机+伪造网关）</h3><p>以上两种方式都会造成被攻击主机断网，所以很快就会被发现了，我们要偷偷地截取数据，所以不能让被攻击主机断网。</p>
<p>主机A的IP地址是192.168.1.2，MAC地址是AA:AA:AA:AA:AA:AA</p>
<p>主机B的IP地址是192.168.1.3，MAC地址是BB:BB:BB:BB:BB:BB</p>
<p>网关的IP地址是192.168.1.1，MAC地址是GG:GG:GG:GG:GG:GG</p>
<p>主机A源源不断得向网关发送应答帧，将该应答帧的发送端以太网地址设置成AA:AA:AA:AA:AA:AA，</p>
<p>但是却将发送端IP地址设置成192.168.1.3，那么所有发给主机B的数据都会被主机A所截获。</p>
<p>主机A源源不断得向被攻击主机B发送应答帧，将该应答帧的发送端以太网地址设置成AA:AA:AA:AA:AA:AA，</p>
<p>但是却将发送端IP地址设置成192.168.1.1，那么所有从主机B发出的数据都会被主机A所截获，因为主机B认为主机A就是网关。</p>
<p>如果主机A没有开启路由转发功能，那么解开截获的帧之后，发现该IP数据报目的IP地址不是自己，那么就会丢弃该IP数据报。</p>
<p>如果主机A此时开启路由转发功能，那么发现该IP数据报的目的IP地址不是自己，那么主机A会根据P数据报的目的IP地址将其封装成正确的帧，从而转发到正确的主机。</p>
<p>封装成帧的时候如果不知道该IP地址所对应的MAC地址，可以发出ARP请求，然后就能获得该IP地址对应的MAC地址。</p>
<p>osx系统命令行查看是否开启路由转发功能sudo sysctl -a | grep forward</p>
<p>osx系统命令行开启路由转发功能sysctl -w net.inet.ip.forwarding=1</p>
<p>osx系统命令行关闭路由转发功能sysctl -w net.inet.ip.forwarding=0</p>
<p>注：必须源源不断地发送伪造的ARP包，因为有的主机（具体看操作系统实现）会定时向网关发送ARP请求，这就会刷新网关和主机自身的ARP缓存，所以ARP攻击必须发的比它们还多，从而掩盖掉它们。</p>
<h2 id="ARP欺骗只能发生在局域网里面吗"><a href="#ARP欺骗只能发生在局域网里面吗" class="headerlink" title="ARP欺骗只能发生在局域网里面吗"></a>ARP欺骗只能发生在局域网里面吗</h2><p>如果不考虑代理ARP的话，那么ARP只能发生在局域网里面，因为ARP广播是不能跨越路由器的。</p>
<p>所以说，如果你要使用ARP攻击某台主机，那么你必须和它在同一个局域网内，这样你就能截获它发往外网的数据，也能截获外网发给它的数据。</p>
<h2 id="ARP欺骗解决方案"><a href="#ARP欺骗解决方案" class="headerlink" title="ARP欺骗解决方案"></a>ARP欺骗解决方案</h2><p>1、在网关路由器中绑定所有PC机和IP地址和MAC地址。 这样就能防止别人伪造成主机了。<br>2、在PC机上绑定网关路由器内网口IP地址和MAC地址。  这样就能防止别人伪造成网关了。</p>
<h2 id="ARP攻击软件"><a href="#ARP攻击软件" class="headerlink" title="ARP攻击软件"></a>ARP攻击软件</h2><p><a href="http://www.pc6.com/mac/129593.html" target="_blank" rel="external">Debookee</a><br>该攻击软件的原理:<a href="http://blog.csdn.net/icodeyou/article/details/49556627" target="_blank" rel="external">mac工具–通过 arp 欺骗抓取局域网内设备数据包</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.2cto.com/Article/201509/441866.html" target="_blank" rel="external">记一次实验室局域网的ARP欺骗</a></li>
<li><a href="http://blog.csdn.net/qq_15437667/article/details/50743182" target="_blank" rel="external">苹果电脑macbook/mac_os开启路由转发功能</a></li>
</ul>
<ul>
<li><a href="http://www.utt.com.cn/reference.php?id=1541" target="_blank" rel="external">三种方法找出内网的ARP攻击源</a></li>
</ul>
<ul>
<li><a href="http://www.cnblogs.com/duanv/p/4589625.html" target="_blank" rel="external">ARP协议抓包之帧长度和Gratuitous ARP的问题</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据链路层的作用&quot;&gt;&lt;a href=&quot;#数据链路层的作用&quot; class=&quot;headerlink&quot; title=&quot;数据链路层的作用&quot;&gt;&lt;/a&gt;数据链路层的作用&lt;/h2&gt;&lt;p&gt;数据链路层有三个作用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为上层的IP模块发送和接收IP数据包。&lt;/li&gt;
&lt;li&gt;为ARP模块发送ARP请求和接收ARP应答。&lt;/li&gt;
&lt;li&gt;为RARP模块发送RARP请求和接收RARP应答。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="ARP" scheme="http://yoursite.com/tags/ARP/"/>
    
  </entry>
  
  <entry>
    <title>hexo + github 搭建博客</title>
    <link href="http://yoursite.com/2016/08/07/hexo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2016/08/07/hexo-github搭建博客/</id>
    <published>2016-08-07T00:51:49.000Z</published>
    <updated>2016-08-07T05:04:13.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>hexo是一个基于node.js的静态博客程序，你可以使用markdown语言来编写你的博客，你可以使用hexo提供的命令将其转换成生成静态网页，hexo会根据主题模板自动将你的文章转为网页。</p>
</blockquote>
<a id="more"></a>
<h2 id="hexo安装和发布流程"><a href="#hexo安装和发布流程" class="headerlink" title="hexo安装和发布流程"></a>hexo安装和发布流程</h2><p><img src="http://obil5saf9.bkt.clouddn.com/20160808hexo_flow" alt="Alt hexo安装和发布流程图"></p>
<h3 id="1-下载Git"><a href="#1-下载Git" class="headerlink" title="1.下载Git"></a>1.下载Git</h3><hr>
<p>我的电脑是osx系统，所以使用brew这个包管理工具，如果是linux系统可以使用apt-get包管理工具。</p>
<p>osx系统使用以下命令下载git<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo brew install git</div></pre></td></tr></table></figure></p>
<p>linux系统使用以下命令下载git<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install git</div></pre></td></tr></table></figure></p>
<h3 id="2-下载node-js"><a href="#2-下载node-js" class="headerlink" title="2.下载node.js"></a>2.下载node.js</h3><hr>
<p>hexo是使用node.js编写的，所以你要安装node.js，hexo才能够正常运行。</p>
<p>osx系统使用以下命令下载node.js<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo brew install nodejs</div></pre></td></tr></table></figure></p>
<p>linux系统使用以下命令下载node.js<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install nodejs</div></pre></td></tr></table></figure></p>
<h3 id="3-下载hexo"><a href="#3-下载hexo" class="headerlink" title="3.下载hexo"></a>3.下载hexo</h3><hr>
<h4 id="1-安装hexo"><a href="#1-安装hexo" class="headerlink" title="1.安装hexo"></a>1.安装hexo</h4><p>使用以下命令安装hexo<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo npm install -g hexo</div></pre></td></tr></table></figure></p>
<p>使用以下命令生成博客的工作目录，以后所有的操作都会在该目录下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo hexo init blog</div><div class="line"><span class="built_in">cd</span> blog <span class="comment">#进入该目录，以后的所有命令都在该目录下执行</span></div></pre></td></tr></table></figure></p>
<p>使用以下命令安装依赖项，会在blog目录中安装node_modules<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo npm install</div></pre></td></tr></table></figure></p>
<h4 id="2-使用hexo"><a href="#2-使用hexo" class="headerlink" title="2.使用hexo"></a>2.使用hexo</h4><p>上面已经完成了hexo的搭建了，接下来只要使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo g</div></pre></td></tr></table></figure></p>
<p>生成静态文件，然后使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo s</div></pre></td></tr></table></figure></p>
<p>开启服务器，那么就可以通过<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 来访问我们自己的博客了。<br>hexo常用的命令有：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">hexo g <span class="comment">#生成静态文件</span></div><div class="line">hexo s <span class="comment">#开启服务器</span></div><div class="line">hexo d <span class="comment">#将.deploy_git部署到你的github</span></div><div class="line">hexo new <span class="string">"postname"</span> <span class="comment">#新建文章</span></div><div class="line">hexo new page <span class="string">"pagename"</span> <span class="comment">#新建页面</span></div></pre></td></tr></table></figure></p>
<h3 id="4-部署到github上"><a href="#4-部署到github上" class="headerlink" title="4.部署到github上"></a>4.部署到github上</h3><hr>
<p>使用以下命令生成SSH Keys<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C<span class="string">"这里是你申请Github账号时的邮箱"</span></div></pre></td></tr></table></figure></p>
<p>将~/.ssh/id_rsa.pub中的公钥添加到github</p>
<p>配置git<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name<span class="string">"这里是你申请Github账号时的name"</span></div><div class="line">git config --global user.email<span class="string">"这里是你申请Github账号时的邮箱"</span></div></pre></td></tr></table></figure></p>
<p>使用以下命令查看是否能够SSH成功github<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-T git@github.com</div></pre></td></tr></table></figure></p>
<p>修改博客根目录下的_config.yml文件，修改文件的最后为<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  <span class="built_in">type</span>: git</div><div class="line">  repo: https://github.com/gzmviavia/gzmviavia.github.io.git <span class="comment">#这里要修改成你自己的参考名</span></div><div class="line">  branch: master</div></pre></td></tr></table></figure></p>
<p>最后使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo d</div></pre></td></tr></table></figure></p>
<p>就可以将项目部署上github上了。<br>其实部署的只是由hexo生成的静态页面，我们书写的markdown还是在本地存储的，所以不要以为你部署到github上你就不用备份本地的博客了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;hexo是一个基于node.js的静态博客程序，你可以使用markdown语言来编写你的博客，你可以使用hexo提供的命令将其转换成生成静态网页，hexo会根据主题模板自动将你的文章转为网页。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
